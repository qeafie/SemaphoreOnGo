1. Подробное описание ситуации
В современных распределённых и параллельных системах проблема конкурентного доступа к общим ресурсам остаётся одной из наиболее актуальных. Одним из эффективных средств решения таких проблем является механизм семафоров. Семафор был впервые введён Э. Дейкстрой в 1965 году как примитив синхронизации для управления доступом нескольких процессов к общему ресурсу. Идея заключается в том, чтобы ограничить количество потоков или горутин, одновременно имеющих доступ к определённому ресурсу, посредством управления счётчиком, который увеличивается при освобождении ресурса и уменьшается при его захвате.

1.1. Проблематика конкурентного доступа
В системах с многопоточностью или многопроцессностью несколько потоков могут пытаться одновременно использовать один и тот же ресурс (например, базу данных, файл, память и т.д.). Если такой доступ не будет должным образом синхронизирован, то возможно возникновение различных ошибок, таких как:

Race conditions (гонки): когда результат работы зависит от неопределённого порядка выполнения потоков.

Deadlock (взаимная блокировка): когда два или более потоков навсегда ждут друг друга, что приводит к зависанию системы.

Starvation (голодание): когда один поток постоянно не может получить доступ к ресурсу из-за постоянного приоритета другим потокам.

Для предотвращения этих ошибок применяются различные синхронизирующие механизмы: мьютексы, условные переменные, барьеры, семафоры и другие. В данной работе особое внимание уделяется семафорам, поскольку они представляют собой универсальный инструмент, применимый как для простых сценариев синхронизации, так и для более сложных архитектурных решений.

1.2. Семафоры: принцип работы и применение
Семафор представляет собой структуру данных, которая инкапсулирует целочисленный счётчик и набор операций для его изменения. Основные операции над семафором:

Acquire (P-операция, уменьшение счётчика): поток пытается «захватить» ресурс, уменьшая значение счётчика. Если значение уже равно нулю, поток блокируется до тех пор, пока какой-либо другой поток не выполнит операцию Release.

Release (V-операция, увеличение счётчика): поток «освобождает» ресурс, увеличивая значение счётчика и, возможно, разблокируя ожидающие потоки.

В операционных системах семафоры широко применяются для управления доступом к критическим секциям кода, организации параллельного выполнения задач и предотвращения взаимоблокировок. Несмотря на их относительную простоту, неправильное использование семафоров (например, нарушение порядка захвата нескольких семафоров) может привести к серьёзным проблемам, таким как deadlock.

1.3. Пример критической ситуации: Deadlock
Рассмотрим ситуацию, когда два потока (или горутины) пытаются одновременно захватить два разных семафора, но делают это в разном порядке. Пусть поток 1 сначала захватывает семафор A, затем пытается захватить семафор B. Поток 2, наоборот, сначала захватывает семафор B, а затем пытается захватить семафор A. В результате:

Поток 1 удерживает семафор A и ожидает освобождения семафора B.

Поток 2 удерживает семафор B и ожидает освобождения семафора A.

Ни один из потоков не может продолжить работу, так как каждый ждет освобождения ресурса, удерживаемого другим. Такая ситуация называется deadlock или взаимной блокировкой.

1.4. Решение проблемы deadlock с использованием семафоров
Чтобы избежать deadlock, необходимо соблюдать унифицированный порядок захвата ресурсов. Если все потоки будут всегда запрашивать семафоры в одном и том же порядке, циклические ожидания будут исключены. Другим решением может быть внедрение механизма таймаутов или использование алгоритмов обнаружения взаимоблокировок, но самый простой и эффективный подход – это строгая регламентация порядка захвата семафоров.

В представленном примере мы покажем две реализации:

Критическая ситуация: два потока захватывают семафоры в разном порядке, что может привести к deadlock.

Решённая ситуация: потоки захватывают семафоры в одном и том же порядке, тем самым исключая взаимоблокировку.

1.5. Паттерн «Semaphore» в проектировании систем
При проектировании конкурентных систем часто используется паттерн «Semaphore», который позволяет:

Ограничить число одновременно работающих потоков, например, для доступа к базе данных или внешнему API.

Создать пул ресурсов, где количество одновременно используемых объектов не превышает заданного лимита.

Организовать схему «читатели-писатели», где несколько потоков могут читать данные одновременно, но запись должна осуществляться эксклюзивно.

В нашем примере мы также рассмотрим две дополнительные задачи:

Resource Pool: реализация системы, где N горутин одновременно могут использовать только M ресурсов. Такая модель позволяет эффективно управлять ограниченными ресурсами, минимизируя вероятность возникновения конфликтов.
Readers-Writers: алгоритм, в котором несколько читателей могут одновременно обращаться к данным, но если начинается запись, то она выполняется эксклюзивно. Это особенно актуально для баз данных и систем, где операции чтения выполняются намного чаще, чем операции записи.

# SemaphoreOnGo

Проект **SemaphoreOnGo** демонстрирует использование семафоров и горутин в языке Go для контроля числа одновременно выполняющихся задач и эффективного управления конкурентностью.

---

## Описание

В Go функции могут выполняться в отдельных *горутинах*, а обмен данными между ними осуществляется через *каналы*. Каналы позволяют безопасно передавать сведения между горутинами, избегая проблем с общей памятью. Благодаря маленькому начальному стеку (2 КБ) и легковесности горутин, их можно создавать сотни тысяч, что делает Go удобным для задач с масштабной конкурентностью.

**Семафор** — один из распространённых паттернов конкурентного программирования. Он ограничивает число одновременно работающих горутин (параллелизм) с помощью буферизованного канала. При создании семафора выделяется канал с заданной ёмкостью N — это максимальное число «разрешений». 
- Когда горутина хочет начать работу с ресурсом, она вызывает `Acquire()`, отправляя пустую структуру в канал.  
- Если канал заполнен (в нём уже N значений), горутина блокируется до вызова `Release()` другими горутинами, которые принимают из канала (тем самым освобождая «место»).  

Таким образом, одновременно могут выполняться не более N горутин. Паттерн полезен, когда необходимо ограничить нагрузку на базу данных, внешний API или любой другой ограниченный ресурс.

---

## Задачи проекта

Ниже перечислены задачи проекта, разделённые на две группы:

- **Надо:** Реализовать структуру `Semaphore` с каналом `chan struct{}` и методами `Acquire()` и `Release()`.  
  **Решение:** См. файл `semaphore.go`

- **Надо:** Написать программу в `main.go`, где несколько горутин выполняют работу через семафор. Перед началом работы каждая горутина должна вызывать `sem.Acquire()`, а после завершения — `sem.Release()`, чтобы ограничить число одновременно активных горутин.  
  **Решение:** См. файл `main.go`

- **Надо:** Организовать сбор результатов работы горутин через отдельный канал. Горутины должны отправлять результаты (или ошибки) в канал, а главная функция — читать из него и обрабатывать.  
  **Решение:** См. файл `main.go`

## Источники и материалы

Ниже перечислены статьи, в которых подробно описываются семафоры, горутины и каналы в Go. Рекомендуется ознакомиться с ними для теоретического обоснования и получения дополнительных примеров.

1. **Учимся применять Semaphore и Worker Pool на Go**  
   <https://habr.com/ru/companies/tuturu/articles/755072/>  
   В статье показаны примеры реализации семафора и пулов горутин с подробным разбором кода.

2. **Паттерны многопоточности в Go**  
   <https://habr.com/ru/articles/852556/>  
   Обзор основных паттернов конкурентности в Go, включая Semaphore, Worker Pool, Fan-in/Fan-out, обработку ошибок через каналы и др.

3. **Конкурентность в Go: пять примеров**  
   <https://habr.com/ru/companies/ru_mts/articles/680324/>  
   Приводятся несколько практических примеров использования каналов и горутин, в том числе шаблон Worker Pool.

4. **Интересные способы использования Go каналов (перевод)**  
   <https://habr.com/ru/articles/278349/>  
   Общий обзор возможностей каналов в Go, включая использование для синхронизации и ограничение параллелизма.
